# README

## 類別 (Class)

當我們進入物件導向程式設計 (OOP) 的領域時，類別 (Class) 扮演了非常重要的角色，它可以被視為物件的設計藍圖或建構計畫。

## 類別屬性 (Class Properties)

類別屬性 (Class Properties) 是定義在類別內部的變數，但它們實際上屬於該類別的物件。
只有在創建了物件實例之後，我們才能訪問和操作這些屬性。
這樣的設計有助於將相關的資料封裝在物件內部，提高了程式碼的結構和可維護性。

## 類別方法 (Class Methods)

類別方法 (Class Methods) 是用來為物件添加功能的函數，它們被定義在類別內部，並屬於該類別的物件。這些方法允許我們在物件上執行特定的操作或行為。

## 方法的參數與引數

您可以像一般函數一樣將變數傳遞給方法。在類別中定義這些變數時，我們稱之為參數 (parameters)；當它們被傳遞給實際物件時，我們稱之為引數 (arguments)。

參數 (Parameters): 在方法或函數的定義中，我們所聲明的變數被稱為參數。這些參數充當一種藍圖，指導著方法應該如何接收外部資料。在類別中，這些參數通常用於描述物件應該接受的資訊。

引數 (Arguments): 當我們實際呼叫方法或函數時，我們所傳遞給它的具體數值或變數被稱為引數。換句話說，引數是參數的具體實例，它們將資料傳遞給方法，讓它能夠執行相應的操作。

## 參數預設值

參數的預設值是在定義函數或方法時，為參數指定的一個預先設定的值。這個預設值表示，如果在呼叫函數或方法時沒有提供相應參數的值，則使用這個預設值。

在 PHP 中，當一個方法的參數包含有預設值（default values）時，這些參數必須放在參數列表的最後面。也就是說，如果一個方法有一個或多個有預設值的參數，這些參數必須是參數列表中的最後幾個。

## 命名引數

命名引數（Named Arguments）是 PHP 8 中引入的一個令人驚艷的功能，它為開發者提供了更靈活和清晰的方式來傳遞函數或方法的引數。這種特性已經在其他語言中存在（例如 Python），它的引入為 PHP 開發者帶來了更多選擇和方便。命名引數的主要特點是，你可以通過指定引數的名稱來傳遞它們，而不僅僅是按照位置順序。

## 建構函式（Constructors）

建構函式是物件導向程式設計中的一種特殊方法，包括 PHP。它們在物件實例化過程中扮演著重要的角色。建構函式在物件創建時「幕後自動呼叫」，用於初始化物件的屬性或執行其他設定任務。

在 PHP 中，建構函式的名稱為 __construct。這個方法在建立類別的新實例時會被自動呼叫。

## 建構函式提升屬性（Constructor Promoted Properties）

PHP8 引入的促進屬性（Promoted Properties）確實讓建構子的屬性賦值更簡潔方便。以前要分別定義屬性、建構子參數，再將參數賦值給屬性，寫了三次相關的程式碼，真的很麻煩 😭。現在有了促進屬性，可以在建構子中直接設定屬性值，省去了許多重複的程式碼 🦾。

## 型態提示（Type Hinting）

型態提示（Type Hinting）確實有助於保持程式碼的一致性和可預測性。不僅如此，還能減少撰寫程式碼的量，因為你不再需要檢查參數是否為正確的型態。

有了型態提示，PHP 在我們的代碼中傳遞錯誤的型態時會主動拋出錯誤，這大大提高了程式的穩定性。型態提示確實是一個好東西，建議在程式中多加使用，能夠使程式更加清晰易讀且減少潛在的錯誤。

## 類別類型宣告（Class Type Declarations）

類型宣告確實有助於防止方法接收到錯誤類型的物件。這樣一來，就能夠在不需額外撰寫檢查的情況下識別任何錯誤的類型。這樣的做法可以提高程式碼的穩定性，同時減少了開發者需要手動檢查類型的工作量。在使用時要注意，確保類型宣告能夠使程式碼更加清晰、可靠。

## 回傳型態宣告（Return Type Declarations）

回傳型態宣告（Return Type Declarations）讓使用者端的程式碼能夠知道呼叫方法後可以期望得到的型態。再一次，這讓我們的程式碼更加可預測和可靠，而每個人都喜歡開發者寫出可預測、可靠的程式碼 🏅。

## 代碼臭味（Code Smell）

代碼臭味是指在程式碼中可能存在的不良編碼實踐，可能導致程式碼難以理解、維護或擴展。這些臭味可能包括重複代碼、長函數、過度複雜的邏輯等。當我們發現代碼中存在臭味時，應該進行重構，改進程式碼的結構和品質，以提高代碼的可讀性和可維護性。這樣可以確保代碼在長期開發中保持健康和可持續。

## 繼承（Inheritance）

繼承是面向物件程式設計（OOP）中一個重要的概念，它使得我們可以建立出更具結構性和模組化的程式碼。透過 extends 這個關鍵字，我們可以實現類別之間的繼承關係。

在繼承中，父類別的屬性和方法可以被子類別所繼承和重用。這樣有助於減少代碼的重複性，同時提高程式碼的可維護性和擴展性。子類別可以在繼承的基礎上擴充或修改父類別的功能。

## 覆寫（Overriding）

在子類別中，如果你定義了一個和父類別中相同名稱的方法，子類別中的方法會覆蓋父類別中同名方法的實現，這稱為方法的覆寫（Overriding）。

當你在子類別中定義了和父類別相同名稱的方法時，當你在子類別的實例上呼叫該方法時，將會執行子類別中的實現而不是父類別中的。這允許子類別修改或擴充父類別的方法，以滿足特定的需求。

## 可見性（Visibility）

可見性是面向物件程式設計（OOP）中一個重要的概念，它用來限制對類別的屬性和方法的訪問權限。在OOP中，有三個可見性關鍵字，分別是：public（公共的）、protected（受保護的）、和private（私有的）。

這些可見性關鍵字允許開發者控制類別的成員對外部的可見性，提高了封裝性和安全性。正確的可見性設計有助於確保程式碼的合理使用，同時隱藏實現細節，使類別的介面更加清晰和易於理解。(意即讓外部使用者不需要關心類別的內部實現，只需了解如何使用公共介面。)

## 封裝（Encapsulation）

封裝是面向物件程式設計（OOP）的四大原則之一，它指的是將資料（屬性）與操作該資料的方法結合在一起的概念。

在封裝中，類別將其內部狀態（資料）保護起來，僅通過公共介面提供對該狀態的訪問。這樣的設計確保了對類別內部實現的隱藏性，外部使用者只能透過公共介面與類別進行互動，而無法直接訪問類別的內部狀態。

更深入地理解封裝：

1. 功能集中（Centralized Functionality）： 封裝確保相關的功能（方法）被定義在一個地方，而不是分散在多個地方。這樣有助於提高程式碼的一致性和可讀性。相關的操作應該被集中在一個地方，使得修改和維護更加容易。

2. 邏輯集中（Centralized Logic）： 封裝將數據和操作數據的方法結合在一起，確保相關的邏輯在同一個類別中。這使得程式碼更加結構化，容易理解，並且邏輯與資料的關聯性更加明確。

3. 資料保護（Data Protection）： 通過將資料設為私有，並提供公共方法來訪問或修改這些資料，封裝確保了對內部狀態的控制。這防止了外部程式碼在不正確的地方意外或非預期地修改物件的內部狀態。這提供了更高的安全性和穩定性。

總的來說，封裝有助於提高程式碼的模組化和可維護性，同時減少了外部使用者對內部實現的依賴。這使得在不影響外部程式碼的情況下，可以更容易地修改和擴展類別的內部實現。

## 類型化屬性（Typed properties）

Typed properties（類型化屬性）允許你聲明類別屬性可以包含的資料型別，確保正確的資料型別被指派給屬性。如果在程式執行時嘗試給這些屬性分配不正確的資料型別，PHP 將引發錯誤。這有助於防止因不正確的資料型別而引起的錯誤，提高程式碼的穩定性。

## 聯合型別（Union types）

Union types（聯合型別）允許在型別聲明中指定多個型別，使用 | 字元來分隔不同的型別，例如string|int，使用聯合型別有助於提高程式碼的靈活性，允許一個變數、屬性或方法接受或返回多種可能的型別。這特別在處理多樣化的資料時非常有用。

## 靜態屬性（Static Properties）

靜態屬性（Static Properties）是具有類別範圍的變數，因此可以在不需要先創建實例的情況下，直接通過類別訪問。

靜態屬性和實例屬性都可以用於存儲和共享資訊。靜態成員更適合用於跨多個實例共享的資訊，而實例成員更適合用於每個實例獨有的資訊。在登入系統中，管理登入狀態可能需要共享資訊，因此靜態屬性和方法可能更合適。而管理每個使用者的個人資訊，則通常需要使用實例屬性和方法。

使用靜態成員的原因有幾點：

1. 在程式的任何地方都可以使用： 靜態成員屬於類別本身，而不是實例。因此，它們可以在程式的任何地方使用，而不受實例的限制。這使得它們在整個應用程式中都是全域可用的。

2. 易於設定和訪問： 靜態成員可以直接通過類別訪問，而不需要先創建類別的實例。這使得設定和訪問靜態成員變得非常簡單。不需要實例化，可以直接透過類別名稱訪問。

3. 相同的值對類別的每個實例都是可用的： 靜態成員的值是與類別相關聯的，而不是與特定的實例。這意味著所有屬於該類別的實例都共享相同的靜態成員值。這有助於在類別層面上共享資訊，而不需要每個實例都保留一份。

總的來說，靜態成員提供了在類別層面上共享資訊的一種機制，同時也簡化了對這些資訊的設定和訪問。在大多數情況下，你可能會發現實例屬性更符合物件導向設計的原則，因為它們更具有封裝性和可測試性。然而，靜態屬性仍然是一個有用的工具，特別是在需要在整個類別中共享資訊時。因此需謹慎使用靜態成員，因為它們可能導致全域狀態的變化，並可能使程式碼更難測試和理解。

## 類別常數（Class Constants）

類別常數是在類別中定義的不可變的數值或標識符。這些常數在整個類別中都是可用的，而且其值在程式執行期間不能被修改。在使用類別常數時，你可以直接透過類別名稱來訪問它們，而不需要實例化類別。

## 抽象類別（Abstract Classes）

抽象類別是那些你不能直接實例化的類別。在程式設計中，抽象類別常常被用來定義一個共同的介面，但不能被直接使用來建立物件。它通常包含抽象方法，這些方法在繼承該抽象類別的子類別中必須被實作。抽象類別的存在有助於建立一個規範，讓子類別實現共同的行為。

## 抽象方法（Abstract Methods）

抽象方法是在抽象類別中被定義但沒有實際內容的方法。
子類別必須實作這些抽象方法，而具體的實作內容則在子類別中被定義。

## 介面（Interfaces）

當我們設計軟體時，介面是一種定義行為的方式，它確保不同的類別可以實作相同的方法或屬性，以達成一致的操作方式。介面通常只宣告方法的簽名，而不提供具體的實作。

這樣的設計有幾個優點。首先，它提供了一種標準，確保了程式碼的一致性。當多個類別實作相同的介面時，我們知道它們都有相同的方法，這使得程式碼更容易理解和維護。

其次，介面也提供了多型性（polymorphism）的支援。當我們使用介面時，我們可以使用介面的型別，而不需要知道實際上是哪個類別在執行。這增加了程式碼的靈活性，使得我們可以更容易地擴展和修改程式。

## 特徵（Traits）

特徵（Traits）是一種類似類別的結構，提供在不能使用繼承的情況下分享功能（方法）的方法。

特徵主要用於解決多重繼承所帶來的問題，因為在某些語言中，一個類別只能繼承自一個類別。當需要在不同的類別中共享相同的功能時，特徵提供了一種更靈活的方式。

## 特徵（Traits）和介面（Interfaces）一起使用

當我們談到特徵和介面一起使用時，我們實際上是在討論如何更靈活和有效地設計和組織程式碼。這種組合可以解決一些傳統繼承模型難以應對的問題，並提供更多的選擇和控制權。

1. 程式碼的重複使用：
	- 特徵允許你將相同或相似的程式碼片段封裝成可重複使用的模組，然後在多個類別中使用它們。
	- 這樣的做法避免了傳統繼承可能引起的問題，並使程式碼更易於維護和擴展。

2. 定義類別的契約：
	- 介面定義了一組類別應該提供的方法，確保這些類別滿足某種契約。
	- 這有助於確保不同的類別可以具有相似的行為，提高程式碼的一致性。

3. 提供更靈活的設計選擇：
	- 結合特徵和介面使得程式設計人員可以更靈活地設計類別，根據實際需求組合和重複使用功能。
	- 這種方式更加模組化，有助於應對不斷變化的需求。

## 在特徵（Traits）中使用抽象方法（Abstract Methods）

在Trait中使用抽象方法的確是可行的，它和在抽象類別中的效果是相同的。Trait中的抽象方法沒有實際的實作，而是留給使用該Trait的類別來實作。這樣的設計可以讓你定義一個通用的行為，同時讓不同的類別根據自己的需求實作具體的方法。這樣的組合方式提供了更大的彈性，讓你可以更靈活地應對各種場景。

## 例外狀況（Exceptions）

在程式設計中，例外狀況（Exceptions）是指在執行過程中出現的意外或錯誤狀況。這些狀況可能會干擾正常的程式流程，但透過異常處理的機制，我們可以更靈活地處理這些問題，避免程式崩潰或提供更友善的錯誤處理方式。

異常可以包括各種情況，如除以零、存取不存在的物件、檔案不存在等。在程式中，我們可以使用try、catch的結構來捕捉和處理異常，確保程式在遇到問題時能夠以一種優雅的方式處理，而不是直接終止執行。

## 例外狀況的子類別（Exception Subclasses）

你可以透過建立例外狀況的子類別（Exception Subclasses）來定義更具體且特定的例外狀況，以更精確地捕捉和處理錯誤。這有助於提供更清晰的錯誤訊息，以及更有效的錯誤處理機制。

## 自訂例外狀況（Custom Exceptions）

在程式設計中，自訂例外狀況（Custom Exceptions）是一種方式，讓你可以定義符合你應用程式需求的特定錯誤狀況。這樣一來，當特定情境發生時，你可以引發自定義的例外狀況，讓程式能夠更有彈性地處理錯誤。

## finally

finally 區塊是一個與 try 和 catch 區塊一同使用的結構，用於確保特定程式碼段落無論是否發生例外狀況，都會被執行。無論 try 區塊中的程式碼是否成功執行，或是在執行過程中是否有例外狀況被拋出，finally 區塊中的程式碼都會被確保執行。

這種結構的主要目的是提供一個確保清理操作或釋放資源的地方，以確保程式的穩定性。通常，開發者會在 finally 區塊中放置需要無論成功還是失敗都執行的程式碼，例如關閉檔案、釋放資源或進行一些清理工作。這有助於確保即使在發生錯誤的情況下，資源也能夠得到正確釋放，避免潛在的資源洩漏或問題。

## 命名空間（Namespaces）

命名空間（Namespaces）在 PHP 中有助於更好地組織程式碼，將一起執行任務的類別群組在一起。這使得代碼更有組織性，更容易理解和維護。

主要的好處包括：

1.組織程式碼： 命名空間允許你將相關聯的類別放在一個命名空間下，從而形成更有結構的程式碼。這有助於提高代碼的可讀性和可維護性。

2.避免名稱衝突： 當不同的程式碼部分使用相同的名稱時，可能會產生命名衝突。使用命名空間可以避免這種衝突，因為每個命名空間提供了一個封閉的範疇，允許相同名稱的類別在不同的命名空間中存在。

3.同名類別的使用： 命名空間允許你在同一個應用中使用相同名稱的類別，只要它們處於不同的命名空間。這是一種有效的方式，可以在不同上下文中使用相同名稱的類別，而不會引起衝突。

## 自動加載（Autoloading）

Autoloading（自動加載）是一種讓程式自動載入所需檔案的機制，無需手動使用 require 或 include 來引入每個檔案，這樣就能減少混淆和可能導致錯誤的情況。這對於大型專案來說特別有用，讓程式更加模組化和易於維護。通常，程式語言的框架或庫會提供自動加載的功能，以簡化開發過程。

## 套件管理工具 Composer

Composer 是一個相當方便的相依性管理工具，除了管理相依性外，還有一些額外的功能。我們可以利用 Composer 在我們的專案中加入第三方的 PHP 套件。這讓我們更容易管理專案所需的各種套件，同時也確保了這些套件的版本相容性。透過 Composer，我們可以輕鬆地引入、更新、或移除套件，使開發過程更為靈活和高效。

## 套件儲存庫 Packagist

Packagist 是一個 PHP 的套件儲存庫，用來管理和分享 PHP 套件。你可以在 Packagist 上找到各種 PHP 套件，並透過 Composer 工具來安裝和管理這些套件。這個平台方便了 PHP 開發者分享和使用各種程式庫和工具，有助於提高開發效率。

https://packagist.org/

## 使用 Composer 的自動載入功能

Composer 是一個強大的套件管理工具，它不僅可以處理第三方套件的載入，還能夠方便地處理我們自己建立的類別的自動載入。

## 檢查類別（Inspecting Classes）

檢查類別（Inspecting Classes）指的是在程式執行期間，動態地檢查和獲取類別相關資訊的行為。這包括了查詢類別是否存在、獲取類別名稱、獲取類別的方法、以及獲取物件的屬性等操作。

## Reflection API

Reflection API（反射 API）是 PHP 中的一套強大工具，用於在執行時期獲取類別、方法、屬性等相關資訊。這對於動態生成程式碼、除錯和程式分析等場景非常有用。

## 單一職責原則（Single Responsibility Principle，SRP）

單一職責原則（Single Responsibility Principle，簡稱SRP）就是要讓每個程式碼部分只做一件事情。就好像一個人應該只負責一項工作，而不是同時處理多項不同的事情。

舉例來說，如果你有一個處理檔案的程式，那麼這個程式應該只處理檔案的讀寫，而不要同時去處理資料的操作。這樣可以確保程式碼容易維護和理解，因為每個部分都專注在一個特定的任務上。

如果一個類別或一個函式裡面有太多不同的事情要做，這樣的程式碼可能會變得混亂難懂，也不容易修改。所以，單一職責原則的目標就是確保每個程式碼部分都有明確而簡單的責任，這樣整個系統就會更容易管理。

## 組合（Composition）

組合（Composition）是一種在程式設計中使用的概念，它指的是建立一個物件，該物件由其他物件組成。這種方式允許你建立更大、更複雜的物件，而這些物件的行為和屬性來自於組成它們的小型元件。

以物件導向的觀點來看，組合通常分為兩種主要類型：

1. 聚合（Aggregation）： 表示一種「有一」的關係，當我們談到「有一」的關係時，就像是一個物件裡可以包含其他物件，但這些被包含的物件並不是完全依賴在這個物件上。換句話說，被包含的物件仍然可以獨立存在，就像是一個大學可以有很多學生，但學生可以選擇離開學校而存在。

2. 合成（Composition）： 表示一種更強烈的「擁有」的關係，而當我們說到更強烈的「擁有」關係，就像是一個物件包含其他物件，而這些被包含的物件的生命週期與包含它們的物件相關聯。這種關係就像是一個房子擁有房間，房間的存在和房子的存在是密不可分的，如果房子不存在，房間也就不存在了。

簡單來說，「有一」就像是關係鬆散，被包含的物件可以有自己的生命週期；而「擁有」則表示關係更緊密，被包含的物件的生命週期和包含它們的物件有著密切的關聯。

## 依賴注入（Dependency Injection）

依賴注入（Dependency Injection）基本上是提供一個物件所需的其他物件（它的依賴），而不是讓它自己建構這些物件。在程式設計中，這種做法有助於減少耦合性，提高程式碼的可測試性和可維護性。透過依賴注入，我們可以將依賴的物件注入（傳遞）給目標物件，使得目標物件不需要自行創建這些依賴，而是透過外部提供。這有助於更靈活、可擴充的程式架構。

## 多型（Polymorphism）

多型性是一種程式語言的能力，它可以為多種不同的底層資料類型呈現相同的介面。在物件導向程式設計中，多型性讓相同的方法可以被不同類型的物件呼叫，這有助於程式碼的彈性和可擴展性。這種特性讓程式設計者能夠以一致的方式處理不同型別的資料，提高程式碼的可讀性和維護性。

## Callables

Callables 是 PHP 中的一種強大功能，允許您將函數和其他程式碼塊視為值。這意味著您可以將它們作為參數傳遞給其他函數、存儲在變數中，甚至從函數中返回。它們提供了一種靈活的方式來實現回調、自定義排序邏輯、事件處理等。

1. 促進程式碼重用性和模組化。
2. 啟用靈活和動態行為。
3. 促進事件驅動程式設計。
4. 改善程式碼組織和可讀性。

## 匿名類別（Anonymous Classes）

匿名類別在程式設計中是一種方便的工具，尤其適合處理一些小型任務。它允許你在需要時直接創建一個物件，而不需要事先定義一個具名的類別。這樣可以簡化程式碼，特別是當你只需在一處使用該物件時。匿名類別通常用於實現介面、抽象類別或者擴展父類別，並且可以在程式碼的特定區域內即時定義和使用。

## 單例模式（Singleton Pattern）

單例模式（Singleton Pattern）是一種軟體設計模式，旨在確保一個類別只有一個實例，並提供一個全域訪問點來訪問該實例。這種模式通常用於一些需要共享資源（如資料庫連線、檔案管理器等）的情境，以確保該資源在整個應用程式中的唯一性。

使用單例模式時要小心，因為過度使用可能導致全域訪問點過多，增加程式碼的耦合性。然而，在某些情況下，如共享資源的管理，單例模式仍然是一種有用的設計模式

## 可數介面（Countable Interface）

"當程式碼需要確定一個物件中有多少元素時，可以使用這個方法。"

可數介面（Countable Interface）是一種在程式設計中常見的介面，用於表示一個物件具有可計數的特性。在許多程式語言中，特別是在物件導向程式設計中，這個介面通常用於表示一個容器類型（如陣列、串列、集合等）中的元素可以被計數。

一個實作了可數介面的類別需要提供一個 count() 方法，該方法返回容器中元素的數量。當程式碼需要確定一個物件中有多少元素時，可以使用這個方法。這使得程式碼更具靈活性，因為它可以針對不同的容器類型使用相同的介面方法來獲取元素數量，而不需要關心具體實作。

使用可數介面的主要好處之一是它使得程式碼更容易重用和維護。當你實作了可數介面，你的類別就可以與標準函式庫中的其他函式和工具協同工作，這些函式和工具通常都期望能夠與可數的容器類型一起使用。

## PHPUnit Setup

PHPUnit 是一個用於 PHP 程式碼測試的流行框架。以下是設置 PHPUnit 的基本步驟：

1. 安裝 PHPUnit：使用 Composer 來安裝 PHPUnit，這是最常見的方法。在命令列中執行以下指令：

```lua
composer require --dev phpunit/phpunit
```

## 測試物件（Testing Objects）

在軟體開發中，測試物件（Testing Objects）是指對程式碼中的各種物件進行測試，以確保它們正確地執行其預期的功能。這包括單元測試、整合測試、端對端測試等各種測試方法。

單元測試是測試程式中最小的可測試部分，通常是單個函式、方法或類別。在單元測試中，我們會將被測試的物件（如函式或方法）與預期的結果進行比較，以確保它們符合預期。

整合測試則是測試多個物件之間的交互作用，以確保它們能夠正確地協同工作。這可能涉及到將多個類別或模組結合在一起，然後測試它們的整體行為。

端對端測試則是測試整個應用程式或系統的功能，模擬真實使用者的操作，以確保應用程式在各種情況下都能正常運作。

在進行測試時，我們通常會使用測試框架和工具，如PHPUnit（PHP）、JUnit（Java）、Pytest（Python）、JUnit（Java）、Mocha（JavaScript）等，這些工具提供了方便的方法來創建、執行和管理測試。

測試物件的目的是確保程式碼的品質和穩定性，並減少因修改程式碼而引入的錯誤。透過持續測試和自動化測試，開發人員可以更加自信地進行程式碼的修改和重構，同時確保程式的功能性不受影響。

## setUp method

在測試框架中，setUp 方法是一個特殊的方法，用於設置測試案例所需的初始狀態。通常，setUp 方法在每個測試案例運行之前都會被執行一次，以確保測試環境的一致性和可重複性。

在 PHPUnit 中，setUp 方法是一個測試類別中的一個特殊方法，它必須以 setUp 的名稱來定義，並且不接受任何參數。在 setUp 方法中，您可以初始化測試案例所需的物件、變數或其他資源，以確保測試能夠順利執行。這包括建立測試所需的虛擬環境、準備測試數據、設定測試物件等。

```php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase {
    private $myObject;

    protected function setUp(): void {
        // 在每個測試案例運行之前，初始化測試物件
        $this->myObject = new MyClass();
    }

    public function testSomething(): void {
        // 測試 myObject 的某些方法或行為
        $result = $this->myObject->someMethod();
        $this->assertEquals($expectedResult, $result);
    }

    // 其他測試案例...
}
```

## Error Handling in Tests

在測試中處理錯誤是非常重要的，因為測試過程中可能會遇到各種錯誤情況，如預期之外的異常、無效的輸入等。有效的錯誤處理可以確保測試的準確性和可靠性，並幫助開發人員快速定位和解決問題。

以下是一些處理錯誤的方法和最佳實踐：

1. 使用斷言（Assertions）：在測試中，通過斷言來檢查測試的預期結果是否符合實際結果。常見的斷言包括 assertEquals、assertTrue、assertFalse 等。當斷言失敗時，測試框架會報告錯誤並停止執行當前測試。

2. 捕獲異常：在測試中，可以使用 try-catch 塊來捕獲預期的異常，並進行相應的處理。這樣可以確保當某個操作產生異常時，測試不會因此失敗，而是能夠正確地處理異常情況。

3. 預期異常：有時我們希望測試某個操作是否會產生異常，這時可以使用預期異常的方式來測試。測試框架通常提供了相應的方法來指定測試應該產生異常，如 @expectedException（PHPUnit）或 pytest.raises（Pytest）。

4. 日誌和記錄：在測試過程中，可以使用日誌或記錄來記錄測試的過程和結果，包括錯誤信息、堆棧跟蹤等。這樣可以幫助開發人員更好地理解測試的執行情況，並找出可能存在的問題。

5. 清理和重置：在測試完成後，應該清理和重置測試環境，以確保下一個測試能夠在乾淨的環境中運行。這包括釋放資源、還原狀態等操作。

總的來說，有效的錯誤處理和斷言是測試中不可或缺的一部分，它們可以幫助確保測試的準確性和穩定性，並提高開發人員的工作效率和開發品質。

## 測試替身（Test Doubles）

測試替身（Test Doubles）是在測試中使用的模擬物件，用於替代真實的依賴，以便進行更有效的測試。測試替身可以根據測試案例的需求，模擬各種不同的行為，包括成功、失敗、錯誤處理等，從而使測試更加靈活和可控。

常見的測試替身包括以下幾種：

Dummy Objects（虛設物件）：這些是最簡單的測試替身，它們不實現任何實際的功能，僅用於滿足方法的參數或依賴的需求。通常，它們只是一個空的物件，用於填充參數列表或滿足方法的呼叫。

Stub Objects（存根物件）：存根物件是有預先定義行為的測試替身，它們模擬了特定的行為，並根據測試案例的需要返回預設的結果。存根通常用於模擬對外部系統或服務的調用，以便在測試中模擬不同的情況和結果。

Mock Objects（模擬物件）：模擬物件是一種更進階的測試替身，它們不僅模擬了特定的行為，還提供了對方法呼叫的驗證功能。這意味著我們可以在測試中檢查模擬物件的方法是否被正確地呼叫，以及呼叫的參數是否符合預期。

Spy Objects（間諜物件）：間諜物件與模擬物件類似，但它們還記錄了方法的呼叫和參數，以便在測試結束後進行進一步的分析和驗證。間諜物件通常用於測試方法的互動性，以確保它們與其他物件正確地協同工作。

透過使用測試替身，開發人員可以更輕鬆地創建獨立於外部依賴的測試，並模擬各種不同的情況和情境，從而提高測試的靈活性和可靠性。這使得測試更容易撰寫、更容易理解，同時還能提供更高的測試覆蓋率和更穩定的測試結果。

## 模擬依賴（Mocking a Dependency）

在軟體開發中，模擬依賴是一種常見的技術，用於測試一個元件或類別時，模擬其所依賴的外部物件或服務。這可以使測試更加獨立和可控，同時減少對真實依賴的需求，例如外部 API 請求、資料庫訪問等。

在模擬依賴時，通常會使用模擬框架或庫，如 PHPUnit（PHP）、Mockito（Java）、unittest.mock（Python）等，這些工具提供了創建模擬物件的功能，並且可以定義模擬物件的行為和預期結果。

進一步解釋為什麼要使用模擬物件（mock）:

1. 隔離測試範圍：模擬物件使我們能夠隔離正在測試的單個單元，而不受其依賴物件的影響。在這個測試中，我們只關心 Inventory 物件的行為，而不是 ProductRepository 的實際實現。使用模擬物件可以消除外部依賴對測試的影響，從而使測試更加獨立和可靠。

2. 控制測試環境：通過模擬 ProductRepository，我們可以控制測試的環境，使其符合測試的需求。在這個測試中，我們模擬了 fetchProducts 方法，並指定它應該返回一個特定的產品列表。這樣我們就可以確保在測試中使用的產品數據是可控的和預期的。

3. 提高測試速度：使用模擬物件可以避免不必要的外部調用，從而提高測試的執行速度。在實際的應用中，可能需要從外部系統或服務獲取數據，這可能會增加測試的執行時間。通過模擬這些外部依賴，我們可以避免這些調用，從而加快測試的執行速度。

## 測試驅動開發（Test-Driven Development，TDD）

這是一個常見的軟體開發流程，通常被稱為測試驅動開發（Test-Driven Development，TDD）。以下是這個流程的步驟：

1. 寫一個失敗的測試（Write a failing test）： 首先，你寫一個測試，期望它會失敗，因為你還沒有實現相應的功能。這可以確保你的測試是有效的，並且你的程式碼目前還沒有達到預期的功能。

2. 寫足夠的程式碼使測試通過（Write enough code to make the test pass）： 接下來，你寫足夠的程式碼來使測試通過。這通常意味著你只實現了足夠的功能來滿足測試的需求，而不是添加任何多餘的代碼。

3. 重構代碼（Refactor for clean, working code）： 最後，當你的測試通過時，你可以開始重構你的程式碼。這意味著你可以優化和改進你的程式碼，使其更加簡潔、清晰和易於理解。重構不應該改變程式碼的行為，只是改進程式碼的結構和可讀性。

這個流程的重點在於先寫測試，再實現功能，最後再進行重構。這樣可以確保你的程式碼是根據實際需求編寫的，並且在整個開發過程中保持良好的品質。

## 複合模式（Composite Pattern）

複合模式是一種結構型設計模式，它允許你將物件組織成樹狀結構，使得用戶可以以同樣的方式處理個別物件和物件集合。這個模式通常用於處理部分-整體的關係，讓客戶端程式碼可以一致地操作個別對象和對象集合，而不需要關心它們的具體類型。

在複合模式中，有兩種主要角色：

1. 組件（Component）：定義了一個對象接口，可以是個別對象或者組合的部分。組件包括了所有子類的共同行為，並提供了一些默認的方法。這個介面可以是抽象類或者介面。

2. 複合組件（Composite）：實現了組件接口，代表了具有子組件的物件。複合組件將組件組合成樹狀結構，並實現了在組合中定義操作的方法。

透過複合模式，你可以以一致的方式處理個別對象和組合對象，從而簡化了客戶端程式碼的操作。這個模式在構建具有部分-整體關係的系統時特別有用，例如樹狀結構、圖形編輯器等。

## 裝飾者模式（Decorator Pattern）

裝飾者模式（Decorator Pattern）是一種設計模式，屬於結構型模式之一。在這個模式中，你可以動態地將額外的功能添加到物件上，而不需要修改其原始程式碼。這種模式通常用於需要在不影響其他物件的情況下，對個別物件添加額外功能或行為的情況。基本上，裝飾者模式允許你將物件包裝在另一個物件中，從而疊加功能。

這個模式的核心概念是以組合的方式動態地擴展物件的功能。舉例來說，假設你有一個基本的物件，比如一個咖啡，你可以用裝飾者模式來動態地加入不同的裝飾，比如加奶、加糖、加香料等，而不需要修改原本的咖啡物件。

在裝飾者模式中，通常有一個抽象的基礎類別，代表被裝飾的物件，以及一系列具體的裝飾類別，每個裝飾類別都擁有自己的功能，同時也可以透過組合來添加其他裝飾。

這個模式的優點包括能夠動態地添加功能、不需要修改現有程式碼、容易擴展等。然而，使用這個模式時需要小心避免裝飾層次過多，造成程式碼過於複雜的問題。

## Readonly Properties and Classes 

在 PHP 8.1 版本中，引入了 readonly 屬性，它是一種只能在初始化時設置一次並且之後無法修改的屬性，因此它們是不可變的。可以使用以下語法使單個屬性為 readonly：

```php
readonly public string $someProperty;
```

如果您希望讓類中的所有屬性都是 readonly，您可以簡單地將類聲明為 readonly，如下所示：

```php
readonly class SomeClass {}
```

## 列舉（Enums）

列舉（Enums）提供一種方式，可以為一個型別定義一組固定的值。

許多事物都有一組固定的值：

一週的日子
基本方向
HTTP 狀態碼
撲克牌花色
字母表

在列舉被引入之前，我們通常會使用帶有字串或整數類型的常數來表示上述的所有事物。
然而，沒有什麼可以阻止使用不受控制的值，因為唯一的限制就是它們的類型。列舉為我們解決了這個問題，幫助我們僅處理那些屬於該固定集合的有效成員值。

## Pure Enums vs Backed Enums

# gary-clarke-oop
